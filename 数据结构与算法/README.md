---
typora-root-url: image
---

# 数据结构与算法总结

## 1、绪论

1.在数据结构中，从逻辑上可以将之分为(  )。
A.  动态结构和静态结构
B.  紧凑结构和非紧凑结构
C.  内部结构和外部结构                    
D.  线性结构和非线性结构
【参考答案】D

2.己知表头元素为c的单链表在内存中的存储状态如下表所示
现将f放于1014H处并插入到单链表中，若f在逻辑上位a和e之间，则a，e，f的链接地址依次是(   )。
A．1010H, 1014H, 1004H 	B．1010H, 1004H, 1014H
C．1014H, 1010H, 1004H 	D．1014H, 1004H, 1010H
【2012年全国硕士研究生入学计算机学科专业基础综合试题】
【参考答案】D

![00](/00.jpg)

3.设n是描述问题规模的非负整数，下面程序片段的时间复杂度是（）

```c++
x=2;
while(x<n/2)
    x=2*x;
```

A．O(log2n)		  B．O(n)
C．O(nlog2n)		D．O(n2) 
【2011年全国硕士研究生入学计算机学科专业基础综合试题】
【参考答案】A

4.求整数n(n>=0)阶乘的算法如下，其时间复杂度是(   )。

```c++
int fact(int n){
    if (n<=1)    return 1；
    return     n*fact(n-1)；
}
```

A．O(log2n)			  B．O(n)
C．O(nlog2n)			D．O(n2) 
【2012年全国硕士研究生入学计算机学科专业基础综合试题】
【参考答案】B

5.下列程序段的时间复杂度(   )。

```c++
count=0;
for(k=1; k<=n; k*=2)
    for(j=1; j<=n; j+=1)
        count++; 
```

A．O(log2n)			  B．O(n)
C．O(nlog2n)			D．O(n2) 
【2014年全国硕士研究生入学计算机学科专业基础综合试题】
【参考答案】C

6.下列函数的时间复杂度(   )

```c++
int func(int n)
{
    int i=0,sum=0;
    while( sum<n ) sum += ++i;
    return i;
}
```

A．O(log2n)		B．O(n1/2)
C．O(n)			    D．O(nlog2n)
【2017年全国硕士研究生入学计算机学科专业基础综合试题】
【参考答案】B

## 2、线性表

### 抽象数据类型

1.己知一个带有表头结点的双向循环链表L，结点结构为`（prev，data，next）`，其中`prev和next`分别是指向其直接前驱和直接后继结点的指针。现要删除指针p所指的结点，正确的语句序列是(  D )。

```C++
A．p->next->prev = p->prev;    p->prev->next = p->prev;   free (p);
B．p->next->prev = p->next;    p->prev->next = p->next;   free (p);
C．p->next->prev = p->next;    p->prev->next = p->prev;   free (p);
D．p->next->prev = p->prev;    p->prev->next = p->next;   free (p);
```



### 算法设计

1.已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为0(n)、空间复杂度为0(1)的算法，该算法删除线性表中所有值为item的数据元素。O(1)表示算法的辅助空间为常量。 
【北京航空航天大学2000五(10分)】 

```c++
template <class T>  	    		// 顺序表的元素类型为T
void arrList<T> ::DelAll(T item)
//A是顺序存储的线性表，本算法删除A中所有值为item的元素
 {    int i=0,j=curLen-1;			//设置数组低、高端指针（下标）
      while(i<=j)
      {    while(i<=j && aList[i]!=item)i++;	//若值不为item，右移指针
            while(i<=j && aList[j]==item)j--;	//若值为item，指针左移
            if(i<j)aList[i++]=aList[j--];
      }
      curLen=i;
 }
//若题目要求元素间相对顺序不变，可用如下语句段：
   i=0；j=0； 
   while（j<n）
	    if(aList[j]==item）j++；
        else A[i++]=A[j++]； 
//最后线性表中的元素个数是i。  

```

2.设将n（n>1）个整数存放到一维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法，将R中保存的序列循环左移P（0<P<n）个位置，  即将R中的数据由`（X0,X1,…,Xn-1）`变换为`（Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1）`。要求：
（1）给出算法的基本设计思想。
（2）根据设计思想，采用C 或C++或JAVA 语言描述算法，关键之处给出注释。
（3）说明你所设计算法的时间复杂度和空间复杂度。
 【2010年全国硕士研究生入学统一考试计算机学科专业基础综合】

(1)算法设计思想：
按照下标0到p-1、p到n-1、0到n-1的顺序，将这三段分别逆置，最后的结果即为所求。

(2)

```c++
void leftshift(int R[], int p, int n)
//将有n个元素的一维数组R的序列循环左移p(0<p<n)个位置
{    elemtype t; //t和数组R中的元素具有相同类型
      for(i=0;i<p/2;i++)          //逆置0..p-1段
     {    t=R[i]; R[i]=R[p-1-i]; R[p-1-i]=t;}
     for(i=p;i<(n+p)/2;i++)   //逆置p..n-1段
     {    t=R[i]; R[i]=R[n-1-i+p];R[n-1-i+p]=t;}
     for(i=0;i<n/2;i++)   //逆置0..n-1段，即整个数组逆置
     {    t=R[i]; R[i]=R[n-1-i]; R[n-1-i]=t;}
}//算法初始调用:leftshift(R,p,n)，各参数意义如上。

```

(3)算法执行了两趟逆置，时间复杂度为O(n);用了一个辅助变量空间，空间复杂度为O(1)。
讨论：若采用直接左移p位，空间复杂度仍为O(1)，但时间复杂度为O(np)。

3.已知一个带有表头结点的单链表，结点结构为(data,link)，假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数），若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0，要求： 
⑴ 描述算法的基本设计思想；
⑵ 描述算法的详细实现步骤；
⑶ 根据设计思想和实现步骤，采用程序设计语言描述算法（使用C或C++或JAVA语言实现），关键之处请给出简要注释。
【2009年全国硕士研究生入学计算机学科专业基础综合试题】

```c++
int SearchInvK(const int k)
{ //在单链表la上查找倒数第k个结点
  	p=list->link;  //p指向当前待处理元素
  	q=list;            //若成功,q指向倒数第k个元素
  	i=1;
  	while(p && i<k)  {i++;  p=p->link; }  
  	if(p==null) {cout<<“不存在\n”;  return 0;  }
  	while(p) { q=q->link;  p=p->link; } 
	cout<<“倒数第k个元素的data域：”<<q->data<<endl;
  	return 1;
}//SearchInvK

```

4.假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间。例如，“loading”和“being”的存储映像如下图所示。
![](/01.jpg)
设str1和str2分别指向两个单词所在单链表的头结点，链表结点结构为 <img src="/02.jpg" style="zoom: 50%;" /> 请设计一个时间上尽可能高效的算法，找出由str1和str2所指的两个链表共同后缀的起始位置`（如图中字符i所在结点的位置p）`。要求：
（1）给出算法的基本设计思想。
（2）根据设计思想，采用C或C++或JAVA语音描述算法，关键之处给出注释。
（3）说明你所设计算法的时间复杂度。
【2012年全国硕士研究生入学统一考试计算机学科专业基础综合】

算法思想：

​    找两个单词的共同后缀，应从两个单词的词尾向前找，找到最前边那个相同的字母，就找到了共同后缀。由于本题中单词以单链表存储，若想找到最后字母，需使用栈，这将增大空间复杂度。为不增大空间复杂度，可以先求出两个链表的长度m和n，让两个链表“尾对齐”，即长的链表将指针移到|m-n+1|,短链表的指针指向链表的第一个字母，两个链表进行模式匹配：对应字母比较，从最后遇到两个链表结点值相等，直至到表尾对应结点值都相等为止。要注意处理虽然首次遇到对应结点值相等，但有后续结点值不等的情况,即在匹配中，并非一遇到对应字母相等，就结论后边是共同后缀。

```c++
//求用单链表表示的两个单词的共同后缀的算法
typedef struct Node
	{	ElemType data;
         		struct Node *next;  
     	} LNode,*LinkedList；

int ListLength(LNode *  la)
{//求链表la的长度
       int i=0;
       LNode *p=la->next;   //p指向链表的第一个元素结点
       while(p)
       {    i++;                        //元素个数加1
            p=p->next;             //链表指针后移 
       }
       return i;      // 返回链表的长度
     }

LNode * ComPostfix(LNode *str1, LNode * str2)
{//str1和 str2分别是单词以单链表存储的头指针，本算法返回两个单词共同后缀的起始位置
   p=null; 		//p指向两个链表共同后缀的起始位置
   m=ListLength(str1); 
   n=ListLength(str2);  //求链表str1和str2的长度
   if(m>n) 
   {	s=str1->next;       //s指向长链表的第一个元素
       	q=srt2->next;      //q指向短链表的第一个元素
       	len=m-n+1;         //两个链表开始比较时，长链表应移到的位置
   }
   else
   {	s=str2->next;    //s指向长链表的第一个元素
        	q=srt1->next;    //q指向短链表的第一个元素
        	len=n-m+1;       //两个链表比较时，长链表应移到的位置
   }
}
   i=1;
   while(i<len)
   {    i++; s=s->next;  } //长链表要移到两个链表尾部对齐的位置
   while(s)
    {     while(s && s->data != q->data) 
           //对应字母不等，后移指针
	{	s=s->next; 
                     	q=q->next; 
      	}
     	p=s; 		 //p指向两个链表共同后缀的起始位置
	while(s && s->data==q->data) 
	//如对应字母相等，后移指针
	{	s=s->next; 
                      q=q->next; 
	}
    }
    return p;  //返回两个链表共同后缀的起始位置
 }

```

算法中求了两个链表的长度，接着将长链表的指针移到两链表的比较处，进行对应元素的比较，记住可能共同后缀的开始位置，直到链表尾。总的时间复杂度为O(m+n)。

5.用单链表保存m个整数，节点的结构为(data,link)，且|data|<n(n为正整数)。现要求设计一个时间复杂度尽可能高效地算法，对于链表中绝对值相等的节点，仅保留第一次出现的节点而删除其余绝对值相等的节点。例如若给定的单链表head如下

![](/03.jpg)


删除节点后的head为

![](/04.jpg)

要求
(1) 给出算法的基本思想
(2) 使用c或c++语言，给出单链表节点的数据类型定义。
(3) 根据设计思想，采用c或c++语言描述算法，关键之处给出注释。
(4) 说明所涉及算法的时间复杂度和空间复杂度。

(1) 算法思想：
定义一个大小为N的数组，初始化为0.在遍历链表的同时将数组中索引值为节点的值的绝对值的元素置1.如果此元素已经为1，说明此节点之前已经有与此节点的值的绝对值相等的节点，需将此节点删除。

(2) 节点的数据结构定义如下：

```c++
typedef struct Node
{
    Int data;
    Struct Node * next;
}Node;

```

(3)

```c++
(3)  int a[n]; // 全局数组 标志节点的绝对值的值是否出现过
void DeleteABSEqualNode(Node * head)
{	memset(a,0,n);   // 初始化为0 
?	if (head == NULL) return NULL;	
	Node * p = head;	Node * r = head;
	while (p != NULL)
	{	if (a[abs(p->data)] == 1)  
		//如果此绝对值已经在数组中出现过，则删除
		{r->next = p->next;  delete p;   p = r->next;  }
		else //否则，将数组中对应的元素置1
		{a[abs(p->data)] = 1;  r = p;  p = p->next;   }
	}
	return head;
}
```

(4) 只遍历一次链表，所以时间复杂度为O(n)因为申请大小为n的数组，所以空间复杂度为O(n)，（n为节点绝对值的最大值）。

6.假设一个单循环链表，其结点含有三个域pre、data、next。其中data为数据域；pre为指针域，它的值为空指针（null）；next为指针域，它指向后继结点。请设计算法，将此表改成双向循环链表。

```c++
void  SToDouble（LinkedList  la）
{	while（la->next->pre==null）
	{	la->next->pre=la;  //将结点la后继的pre指针指向la
         	la=la->next；        //la指针后移
	}
}  //算法结束
```

7.请编写算法将单链表L1拆成二个链表，其中以L1为头的链表保持原来向后的链接，另一个链表的表头为L2，其链接方向与L1相反，L1包含原链表的奇数序号的结点，L2包含原链表的偶数序号的结点。
本题可利用链表的“头插法”和“尾插法”求解。
L2链表实际上是L1链表中偶数序号结点的逆置，可采取“头插法”实现。
L1链表包含原链表的奇数序号的结点，保持原来的链接顺序，可采用“尾插法”实现。
时间复杂度为0(n)，空间复杂度为0(1)。

```c++
template <class T> 
void linkList<T> ::divide(linkList<T>*L2) {
    int i = 0;
    Node* p = head->next; 	// p指向当前对象(即L1)的首元结点
    Node* pre = head;	// pre指向p的前驱
    Node* s;
    while(p){
        i++;	
        if(i % 2) {		// 奇数序号结点按原顺序存放于当前对象中
            pre->next = p; 	// 尾插法，保持原顺序
            pre = p; 
            p = p->next;
        }
        else {			// 偶数序号结点逆序插入到L2中
                    s = p->next;
                    p->next = L2->head->next; // 头插法，逆序
                    L2->head->next = p;		
                    if(i == 2)L2->tail = p; // 第2个结点最先插入L2表中，成为尾结点
                    p = s;
                } 
            }
            pre->next = NULL;	// 置L1表尾结点的指针域为NULL
            tail = pre;
        }

```

8.设head是带头结点的单链表的头指针，试写出算法，按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间。要求不允许使用数组作辅助空间。
本题可用选择排序的思路来求解，在每趟遍历中查找链表的最小值结点以及最小值结点的前驱，输出并释放最小值结点所占空间；再查找次最小值结点，输出并释放空间，如此下去，直至链表为空，最后释放头结点所占存储空间。时间复杂度为O(n^2)。

```c++
template <class T> 
void  linkList<T> ::miniDelete(){
    Node* p,* pre,* u; 
    while(head->next != NULL){	// 循环到仅剩头结点
        pre = head;	// pre为指向最小值结点的前驱结点的指针
        p = pre->next;			// p为工作指针遍历链表
        while(p->next != NULL){
            if(p->next->data < pre->next->data){
                pre = p; 			// 记住当前最小值结点的前驱
                p = p->next;
            }	
            else p = p->next;
        }
            cout<<pre->next->data<<" ";// 输出最小值
                    u = pre->next;
                    pre->next = u->next; 
                    delete u;		// 删除最小值结点，释放结点空间
                }
                cout<<endl;
                delete head;		// 释放头结点
            }

```

## 3、栈

1.设输入元素为1、2、3、P和A，输入次序为123PA，如图（编者略）。元素经过栈后达输出序列，当所有元素均到达输出序列后，有哪些序列可以作为高级语言的变量名。
【中山大学 1997】
答案：PA321  P3A21  P32A1  P321A  AP321

2.若元素a，b，c，d，e，f依次进栈，允许进栈、退栈操作交替进行，但不允许连续三次进行退栈操作，则不可能得到的出栈序列是
A. d,c,e,b,f,a   
B. c,b,d,a,e,f   
C. b,c,a,e,f,d    
D. a,f,e,d,c,b
【2010年全国硕士研究生入学统一考试  计算机学科专业基础综合】
【参考答案】D

3.元素a，b，c，d，e依次进入初始为空的栈中，若元素进栈后可停留、可出栈，直到所
有元素都出栈，则在所有可能的出栈序列中，以元素d开头的序列个数是
A. 3                       B. 4
C. 5                       D. 6
【2011年全国硕士研究生入学统一考试计算机学科专业基础综合】
【参考答案】B     出栈顺序必为`d_c_b_a_，e`的顺序不定，在任意一个“__”上都有可能。

4.一个栈的入栈序列为 1, 2, 3,…,n，其出栈序列是 `p1, p2 , p3…pn`。若 p2为 3 ，则 p3 可能取值的个数是
A.n-3     		B.n-2      		
C.n-1			 D.无法确定

【参考答案】C 
解析：除了3本身以外，其他的值均可以取到，因此可能取值的个数为n-1。 